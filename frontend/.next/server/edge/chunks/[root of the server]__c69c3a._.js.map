{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/app/api/chat/route.ts"],"sourcesContent":["import { NextRequest } from 'next/server';\n\nexport const runtime = 'edge';\n\nexport async function POST(req: NextRequest) {\n  try {\n    const body = await req.json();\n    const { messages } = body;\n\n    // Create a new TransformStream for streaming\n    const encoder = new TextEncoder();\n    const stream = new TransformStream();\n    const writer = stream.writable.getWriter();\n\n    // Start the fetch request to the backend\n    const backendResponse = await fetch('http://localhost:8000/chat', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ messages }),\n    });\n\n    if (!backendResponse.ok) {\n      throw new Error('Backend request failed');\n    }\n\n    // Get the response reader\n    const reader = backendResponse.body?.getReader();\n    if (!reader) {\n      throw new Error('No reader available from backend');\n    }\n\n    // Process and forward the stream\n    (async () => {\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) {\n            await writer.close();\n            break;\n          }\n\n          // Forward the chunk with the 'data: ' prefix for SSE\n          const chunk = encoder.encode(`data: ${new TextDecoder().decode(value)}\\n\\n`);\n          await writer.write(chunk);\n        }\n      } catch (error) {\n        console.error('Error processing stream:', error);\n        await writer.abort(error as Error);\n      }\n    })();\n\n    // Return the stream response\n    return new Response(stream.readable, {\n      headers: {\n        'Content-Type': 'text/event-stream',\n        'Cache-Control': 'no-cache',\n        'Connection': 'keep-alive',\n      },\n    });\n  } catch (error) {\n    console.error('Error in chat API route:', error);\n    return new Response(JSON.stringify({ error: 'Internal Server Error' }), {\n      status: 500,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    });\n  }\n} "],"names":[],"mappings":";;;;AAEO,MAAM,UAAU;AAEhB,eAAe,KAAK,GAAgB;IACzC,IAAI;QACF,MAAM,OAAO,MAAM,IAAI,IAAI;QAC3B,MAAM,EAAE,QAAQ,EAAE,GAAG;QAErB,6CAA6C;QAC7C,MAAM,UAAU,IAAI;QACpB,MAAM,SAAS,IAAI;QACnB,MAAM,SAAS,OAAO,QAAQ,CAAC,SAAS;QAExC,yCAAyC;QACzC,MAAM,kBAAkB,MAAM,MAAM,8BAA8B;YAChE,QAAQ;YACR,SAAS;gBACP,gBAAgB;YAClB;YACA,MAAM,KAAK,SAAS,CAAC;gBAAE;YAAS;QAClC;QAEA,IAAI,CAAC,gBAAgB,EAAE,EAAE;YACvB,MAAM,IAAI,MAAM;QAClB;QAEA,0BAA0B;QAC1B,MAAM,SAAS,gBAAgB,IAAI,EAAE;QACrC,IAAI,CAAC,QAAQ;YACX,MAAM,IAAI,MAAM;QAClB;QAEA,iCAAiC;QACjC,CAAC;YACC,IAAI;gBACF,MAAO,KAAM;oBACX,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,OAAO,IAAI;oBACzC,IAAI,MAAM;wBACR,MAAM,OAAO,KAAK;wBAClB;oBACF;oBAEA,qDAAqD;oBACrD,MAAM,QAAQ,QAAQ,MAAM,CAAC,CAAC,MAAM,EAAE,IAAI,cAAc,MAAM,CAAC,OAAO,IAAI,CAAC;oBAC3E,MAAM,OAAO,KAAK,CAAC;gBACrB;YACF,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,4BAA4B;gBAC1C,MAAM,OAAO,KAAK,CAAC;YACrB;QACF,CAAC;QAED,6BAA6B;QAC7B,OAAO,IAAI,SAAS,OAAO,QAAQ,EAAE;YACnC,SAAS;gBACP,gBAAgB;gBAChB,iBAAiB;gBACjB,cAAc;YAChB;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,IAAI,SAAS,KAAK,SAAS,CAAC;YAAE,OAAO;QAAwB,IAAI;YACtE,QAAQ;YACR,SAAS;gBACP,gBAAgB;YAClB;QACF;IACF;AACF"}},
    {"offset": {"line": 92, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 97, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 97, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}